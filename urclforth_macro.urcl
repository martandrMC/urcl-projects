run rom
bits 16

// Total RAM = 512 Cells (1 KiB)
minheap 184
minstack 32

// Forth VM Register Set (8 total)
minreg 7
@define dsp sp // Data Stack Pointer
@define rsp r1 // Return Stack Pointer
@define vip r2 // Virtual Instruction Pointer
@define cfa r3 // Code Field Address
@define tr1 r4 // Temporary Register 1
@define tr2 r5 // Temporary Register 2
@define tr3 r6 // Temporary Register 3
@define tr4 r7 // Temporary Register 4

// The length in the dictionary has a few flags on it too
@define FLAG_RUNIMM 0x80 // Run immediately when encountered
@define FLAG_HIDDEN 0x40 // Ingored by dictionary lookups
@define MASK_LENGTH 0x0f // Only up to 16 chars for the name

////////////////////////////////////////////////////////////
//                    URCL ENTRYPOINT                     //
////////////////////////////////////////////////////////////

// The last 8 cells are for the RSP
// Memset them to AAAA so they are visible
mov rsp sp
imm tr1 8
.fill_rs
    psh 0xAAAA
    dec tr1 tr1
bnz .fill_rs tr1

// The following 24 cells are for the DSP
// Memset them to BBBB so they are visible
imm tr1 -24
.fill_ds
    lstr dsp tr1 0xBBBB
    inc tr1 tr1
bnz .fill_ds tr1

// Initialise TDS, TRS constants
lstr .code_tds 1 dsp
lstr .code_trs 1 rsp

// Inline version of .next to call the abort word
// Don't want to place down a DW just for this
imm cfa .code_abort
lod tr1 cfa
jmp tr1

@debug
hlt // we should never reach here

////////////////////////////////////////////////////////////
//                   RUNTIME ESSENTIALS                   //
////////////////////////////////////////////////////////////

// Every primitive word ends by jumping here
// Jump to the next word's CFA and advance the VIP
.next
    lod cfa vip
    inc vip vip
    lod tr1 cfa
    jmp tr1

// CFA of function words points to this
// Saves the VIP to the RS and jumps to the
// word sequence in the DFA of the word
.run_func
    dec rsp rsp
    str rsp vip
    add vip cfa 1
    jmp .next

// CFA of constant words points to this
// Pushes to the DS the first cell of the DFA of the word
.run_const
    llod tr1 cfa 1
    psh tr1
    jmp .next

// CFA of variable words points to this
// Pushes to the DS the address of the DFA of the word
.run_var
    add tr1 cfa 1
    psh tr1
    jmp .next

////////////////////////////////////////////////////////////
//                    HELPER FUNCTIONS                    //
////////////////////////////////////////////////////////////

.tell
    brz .tell_done tr1
        lod tr3 tr2
        out %text tr3
        inc tr2 tr2
        dec tr1 tr1
    jmp .tell
    .tell_done
    ret

.word
    imm tr1 0
    .word_loop1
        in  tr2 %text
        out %text tr2
    ble .word_loop1 tr2 ' '
    .word_loop2
        lstr .word_buffer tr1 tr2
        inc tr1 tr1
        bre .word_skip tr1 16
        in  tr2 %text
        out %text tr2
    brg .word_loop2 tr2 ' '
    .word_skip
    imm tr2 .word_buffer
    ret

.number
    imm tr3 0
    .number_next
    brz .number_done tr1
        lod tr4 tr2
        sub tr4 tr4 '0'
        bge .number_done tr4 10
        mlt tr3 tr3 10
        add tr3 tr3 tr4
        inc tr2 tr2
        dec tr1 tr1
    jmp .number_next
    .number_done
    mov tr2 tr3
    ret

.find
    dec tr1 tr1
    add cfa .code_last 1
    .find_next
        lod cfa cfa
        llod tr3 cfa 1
        and tr4 tr3 FLAG_HIDDEN
        bnz .find_length_skip tr4
        and tr3 tr3 MASK_LENGTH
        bne .find_length_skip tr3 tr1
            psh tr1
            add cfa cfa 2
            .find_compare
                llod tr3 cfa tr1
                llod tr4 tr2 tr1
                bne .find_compare_skip tr3 tr4
                dec tr1 tr1
            brp .find_compare tr1
            pop tr1
            sub tr1 cfa 2
            ret
            .find_compare_skip
            pop tr1
            sub cfa cfa 2
        .find_length_skip
    bnz .find_next cfa
    mov tr1 cfa
    ret

.create
    and tr1 tr1 MASK_LENGTH
    brz .create_exit tr1
    llod tr3 .code_free 1
    llod tr4 .code_last 1
    lstr .code_last 1 tr3
    lstr tr3 0 tr4
    dec tr4 tr1
    lstr tr3 1 tr4
    add tr3 tr3 2
    add tr4 tr3 tr1
    lstr .code_free 1 tr4
    .create_copy
        dec tr1 tr1
        llod tr4 tr2 tr1
        lstr tr3 tr1 tr4
    bnz .create_copy tr1
    .create_exit
    ret

.append
    llod tr2 .code_free 1
    str tr2 tr1
    inc tr2 tr2
    lstr .code_free 1 tr2
    ret

////////////////////////////////////////////////////////////
//                INITIAL WORD DICTIONARY                 //
////////////////////////////////////////////////////////////

.word_buffer // Maximum 16 chars between whitespaces
dw [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ]

/////////////////// CONSTANTS + VARIABLES //////////////////

@defvar "state" state 0
@defvar "last" last .dict_last
@defvar "free" free M0

@defconst "tds" tds 0
@defconst "trs" trs 0
@defconst "ifunc" ifunc .run_func
@defconst "ivar" ivar .run_var
@defconst "iconst" iconst .run_const

//////////////////////// PRIMITIVES ////////////////////////

@defprim "exit" exit
    lod vip rsp
    inc rsp rsp
    jmp .next

@defprim "litn" litn
    lod tr1 vip
    inc vip vip
    psh tr1
    jmp .next

@defprim "@" peek
    pop tr1
    lod tr1 tr1
    psh tr1
    jmp .next

@defprim "!" poke
    pop tr1
    pop tr2
    str tr1 tr2
    jmp .next

@defprim "+" add
    pop tr1
    pop tr2
    add tr1 tr1 tr2
    psh tr1
    jmp .next

@defprim "." dot
    pop tr1
    out %numb tr1
    jmp .next

@defprim "d>r" dtor
    pop tr1
    dec rsp rsp
    str rsp tr1
    jmp .next

@defprim "r>d" rtod
    lod tr1 rsp
    inc rsp rsp
    psh tr1
    jmp .next

@defprim "rsp@" rsppeek
    psh rsp
    jmp .next

@defprim "rsp!" rsppoke
    pop rsp
    jmp .next

@defprim "dsp@" dsppeek
    psh dsp
    jmp .next

@defprim "dsp!" dsppoke
    pop dsp
    jmp .next

@defprim "jmp" jmp
    lod tr1 vip
    add vip vip tr1
    jmp .next

@defprim "brz" brz
    pop tr1
    brz .exec_jmp tr1
    inc vip vip
    jmp .next

@defprimi "[" interpret
    llod tr1 .code_state 1
    imm tr1 0
    lstr .code_state 1 tr1
    jmp .next

@defprim "]" compile
    llod tr1 .code_state 1
    imm tr1 1
    lstr .code_state 1 tr1
    jmp .next

@defprim "hidden" hidden
    pop tr1
    llod tr2 tr1 1
    xor tr2 tr2 FLAG_HIDDEN
    lstr tr1 1 tr2
    jmp .next

@defprimi "runimm" runimm
    llod tr1 .code_latest 1
    llod tr2 tr1 1
    xor tr2 tr2 FLAG_RUNIMM
    lstr tr1 1 tr2
    jmp .next

@defprim "create" create
    pop tr1
    pop tr2
    cal .create
    jmp .next

@defprim "append" append
    pop tr1
    cal .append
    jmp .next

@defprim "inp" inp
    in  tr1 %text
    out %text tr2
    psh tr1
    jmp .next

@defprim "out" out
    pop tr1
    out %text tr1
    jmp .next

@defprim "word" word
    cal .word
    psh tr2
    psh tr1
    jmp .next

@defprim "tell" tell
    pop tr1
    pop tr2
    cal .tell
    jmp .next

@defprim "find" find
    pop tr1
    pop tr2
    cal .find
    psh tr1
    jmp .next

@defprim "number" number
    pop tr1
    pop tr2
    cal .number
    psh tr2
    psh tr1
    jmp .next

@defprim "repl" repl
    cal .word
    psh tr1
    psh tr2
    cal .find
    pop tr2
    brz .exec_repl_nodict tr1
        llod tr2 tr1 1
        and tr4 tr2 FLAG_RUNIMM
        and tr2 tr2 MASK_LENGTH
        add tr2 tr2 3
        add cfa tr1 tr2
        pop tr1
        bnz .exec_repl_dict_interp tr4
        llod tr4 .code_state 1
        brz .exec_repl_dict_interp tr4
        mov tr1 cfa
        cal .append
        jmp .next
        .exec_repl_dict_interp
        lod tr1 cfa
        jmp tr1
    .exec_repl_nodict
    pop tr1
    cal .number
    bnz .exec_repl_error tr1
        llod tr4 .code_state 1
        brz .exec_repl_num_interp tr4
        imm tr1 .code_litn
        psh tr2
        cal .append
        pop tr1
        cal .append
        jmp .next
        .exec_repl_num_interp
        psh tr2
        jmp .next
    .exec_repl_error
    out %text '?'
    out %text 'E'
    out %text 'R'
    out %text 'R'
    jmp .next

/////////////////////////// FORTH //////////////////////////

@defforth "abort" abort
dw [ .code_trs .code_rsppoke .code_repl .code_jmp -4 ]

@defforth ":" colon
dw [ .code_word .code_create .code_litn .run_func .code_append ]
dw [ .code_last .code_peek .code_hidden .code_compile .code_exit ]

.dict_last
@defforthi ";" semicol
dw [ .code_litn .code_exit .code_append ]
dw [ .code_last .code_peek .code_hidden .code_interpret .code_exit ]
