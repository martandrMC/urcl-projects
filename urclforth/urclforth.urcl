run rom
bits 16

// Total RAM = 1024 Cells (2 KiB)
minheap 509
minstack 32

// Forth VM Register Set (8 total)
minreg 7
@define dsp sp // Data Stack Pointer
@define rsp r1 // Return Stack Pointer
@define vip r2 // Virtual Instruction Pointer
@define cfa r3 // Code Field Address
@define tr1 r4 // Temporary Register 1
@define tr2 r5 // Temporary Register 2
@define tr3 r6 // Temporary Register 3
@define tr4 r7 // Temporary Register 4

// The length in the dictionary has a few flags on it too
@define FLAG_RUNIMM 0x80 // Run immediately when encountered
@define FLAG_HIDDEN 0x40 // Ingored by dictionary lookups
@define MASK_LENGTH 0x0f // Only up to 16 chars for the name

@define RS_SIZE  8 // Size of the return stack
@define DS_SIZE 24 // Size of the data stack

////////////////////////////////////////////////////////////
//                    URCL ENTRYPOINT                     //
////////////////////////////////////////////////////////////

// The last 8 cells are for the RSP
// Memset them to AAAA so they are visible
mov rsp sp
imm tr1 RS_SIZE
.fill_rs
    psh 0xAAAA
    dec tr1 tr1
bnz .fill_rs tr1

// The following 24 cells are for the DSP
// Memset them to BBBB so they are visible
sub tr1 r0 DS_SIZE
.fill_ds
    lstr dsp tr1 0xBBBB
    inc tr1 tr1
bnz .fill_ds tr1

// Initialise TDS, TRS, EDR constants
lstr .code_tds 1 dsp
lstr .code_trs 1 rsp
sub tr1 dsp DS_SIZE
lstr .code_edr 1 tr1

// Inline version of .next to call the abort word
// Don't want to place down a DW just for this
imm cfa .code_abort
lod tr1 cfa
jmp tr1

////////////////////////////////////////////////////////////
//                   RUNTIME ESSENTIALS                   //
////////////////////////////////////////////////////////////

// Every primitive word ends by jumping here
// Jump to the next word's CFA and advance the VIP
.next
    lod cfa vip
    inc vip vip
    lod tr1 cfa
    jmp tr1

// CFA of procedure words points to this
// Saves the VIP to the RS and jumps to the
// word sequence in the DF of the word
.run_proc
    dec rsp rsp
    str rsp vip
    add vip cfa 1
    jmp .next

// CFA of patch words points to this
// Saves the VIP to the RS, jumps to the
// word sequence pointed to by the cell
// after the CF and pushes the address
// of the address after that to the DS
.run_patch
    dec rsp rsp
    str rsp vip
    llod vip cfa 1
    add tr1 cfa 2
    psh tr1
    jmp .next

// CFA of constant words points to this
// Pushes to the DS the first cell of
// the DF of the word
.run_const
    llod tr1 cfa 1
    psh tr1
    jmp .next

// CFA of variable words points to this
// Pushes to the DS the address of
// the DF of the word
.run_var
    add tr1 cfa 1
    psh tr1
    jmp .next

////////////////////////////////////////////////////////////
//                    HELPER FUNCTIONS                    //
////////////////////////////////////////////////////////////

.inp
    llod tr2 .src_preload_state 0
    sbrl .inp_storage tr2 1
    .inp_hasinit
    in  tr2 %text
    out %text tr2
    ret
    .inp_storage
    not tr2 tr2
    lstr .src_preload_state 0 tr2
    llod tr3 .src_preload_state 1
    out %addr tr3
    bnz .inp_noinc tr2
        inc tr3 tr3
        in  tr4 %addr
        bne ~+2 tr3 tr4
        lstr .src_preload_state 0 1
        lstr .src_preload_state 1 tr3
    .inp_noinc
    mov tr4 tr2
    in  tr2 %bus
    brz ~+2 tr4
    bsr tr2 tr2 8
    and tr2 tr2 0xFF
    ret

.tell
    brz .tell_done tr1
        lod tr3 tr2
        out %text tr3
        inc tr2 tr2
        dec tr1 tr1
    jmp .tell
    .tell_done
    ret

.word
    imm tr1 0
    .word_loop1
        cal .inp
    ble .word_loop1 tr2 ' '
    .word_loop2
        lstr .word_buffer tr1 tr2
        inc tr1 tr1
        bre .word_skip tr1 16
        cal .inp
    brg .word_loop2 tr2 ' '
    .word_skip
    imm tr2 .word_buffer
    ret

.number
    imm tr3 0
    .number_next
    brz .number_done tr1
        lod tr4 tr2
        sub tr4 tr4 '0'
        bge .number_done tr4 10
        mlt tr3 tr3 10
        add tr3 tr3 tr4
        inc tr2 tr2
        dec tr1 tr1
    jmp .number_next
    .number_done
    mov tr2 tr3
    ret

.find
    dec tr1 tr1
    add cfa .code_last 1
    .find_next
        lod cfa cfa
        llod tr3 cfa 1
        and tr4 tr3 FLAG_HIDDEN
        bnz .find_length_skip tr4
        and tr3 tr3 MASK_LENGTH
        bne .find_length_skip tr3 tr1
            psh tr1
            add cfa cfa 2
            .find_compare
                llod tr3 cfa tr1
                llod tr4 tr2 tr1
                bne .find_compare_skip tr3 tr4
                dec tr1 tr1
            brp .find_compare tr1
            pop tr1
            sub tr1 cfa 2
            ret
            .find_compare_skip
            pop tr1
            sub cfa cfa 2
        .find_length_skip
    bnz .find_next cfa
    mov tr1 cfa
    ret

.create
    llod tr3 .code_here 1
    llod tr4 .code_last 1
    lstr .code_last 1 tr3
    lstr tr3 0 tr4
    and tr1 tr1 MASK_LENGTH
    dec tr4 tr1
    lstr tr3 1 tr4
    add tr3 tr3 2
    add tr4 tr3 tr1
    lstr .code_here 1 tr4
    .create_copy
        dec tr1 tr1
        llod tr4 tr2 tr1
        lstr tr3 tr1 tr4
    bnz .create_copy tr1
    .create_exit
    ret

.append
    llod tr2 .code_here 1
    str tr2 tr1
    inc tr2 tr2
    lstr .code_here 1 tr2
    ret

////////////////////////////////////////////////////////////
//                INITIAL WORD DICTIONARY                 //
////////////////////////////////////////////////////////////

.src_preload_state // 0=upper,-1=lower,1=done %addr
dw [ 0 0 ]

.word_buffer // Maximum 16 chars between whitespaces
dw [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ]

/////////////////// CONSTANTS + VARIABLES //////////////////

// 0=Interpret, 1=Compile
.head_state
dw [ 0 0x04 "state" ]
.code_state
dw [ .run_var 0 ]

// First free cell on the dictionary region
.head_here
dw [ .head_state 0x03 "here" ]
.code_here
dw [ .run_var M0 ]

// Last-defined dictionary entry
.head_last
dw [ .head_here 0x03 "last" ]
.code_last
dw [ .run_var .dict_last ]


// Top of Data Stack
.head_tds
dw [ .head_last 0x02 "tds" ]
.code_tds
dw [ .run_const 0 ]

// Top of Return Stack
.head_trs
dw [ .head_tds 0x02 "trs" ]
.code_trs
dw [ .run_const 0 ]

// End of Dictionary Region
.head_edr
dw [ .head_trs 0x02 "edr" ]
.code_edr
dw [ .run_const 0 ]


// CFA for procedures
.head_iproc
dw [ .head_edr 0x04 "iproc" ]
.code_iproc
dw [ .run_const .run_proc ]

// CFA for patch words
.head_ipatch
dw [ .head_iproc 0x05 "ipatch" ]
.code_ipatch
dw [ .run_const .run_patch ]

// CFA for variables
.head_ivar
dw [ .head_ipatch 0x03 "ivar" ]
.code_ivar
dw [ .run_const .run_var ]

// CFA for constants
.head_iconst
dw [ .head_ivar 0x05 "iconst" ]
.code_iconst
dw [ .run_const .run_const ]


// Bit for the run-immediate flag
.head_frunimm
dw [ .head_iconst 0x06 "frunimm" ]
.code_frunimm
dw [ .run_const FLAG_RUNIMM ]

// Bit for the hidden flag
.head_fhidden
dw [ .head_frunimm 0x06 "fhidden" ]
.code_fhidden
dw [ .run_const FLAG_HIDDEN ]

// Length bitmask for dictionary entries
.head_nlength
dw [ .head_fhidden 0x06 "nlength" ]
.code_nlength
dw [ .run_const MASK_LENGTH ]


//////////////////////// PRIMITIVES ////////////////////////

// Get the value of the Return Stack Pointer on the DS
.head_rsppeek
dw [ .head_nlength 0x03 "rsp@" ]
.code_rsppeek
dw [ .exec_rsppeek ]
nop
.exec_rsppeek
    psh rsp
    jmp .next

// Store the value on the DS to the Return Stack Pointer
.head_rsppoke
dw [ .head_rsppeek 0x03 "rsp!" ]
.code_rsppoke
dw [ .exec_rsppoke ]
nop
.exec_rsppoke
    pop rsp
    jmp .next

// Get the value of the Data Stack Pointer on the DS
.head_dsppeek
dw [ .head_rsppoke 0x03 "dsp@" ]
.code_dsppeek
dw [ .exec_dsppeek ]
nop
.exec_dsppeek
    psh dsp
    jmp .next

// Store the value on the DS to the Data Stack Pointer
.head_dsppoke
dw [ .head_dsppeek 0x03 "dsp!" ]
.code_dsppoke
dw [ .exec_dsppoke ]
nop
.exec_dsppoke
    pop dsp
    jmp .next

// Transfer a value from the DS to the RS
.head_dtor
dw [ .head_dsppoke 0x02 "d>r" ]
.code_dtor
dw [ .exec_dtor ]
nop
.exec_dtor
    pop tr1
    dec rsp rsp
    str rsp tr1
    jmp .next

// Transfer a value fromn the RS to the DS
.head_rtod
dw [ .head_dtor 0x02 "r>d" ]
.code_rtod
dw [ .exec_rtod ]
nop
.exec_rtod
    lod tr1 rsp
    inc rsp rsp
    psh tr1
    jmp .next

// Read a value at a given address
.head_peek
dw [ .head_rtod 0x00 "@" ]
.code_peek
dw [ .exec_peek ]
nop
.exec_peek
    pop tr1
    lod tr1 tr1
    psh tr1
    jmp .next

// Store a given value to a given addres
// Address is ontop of the value
.head_poke
dw [ .head_peek 0x00 "!" ]
.code_poke
dw [ .exec_poke ]
nop
.exec_poke
    pop tr1
    pop tr2
    str tr1 tr2
    jmp .next

// Increment the contents of a given addres
.head_incpoke
dw [ .head_poke 0x01 "+!" ]
.code_incpoke
dw [ .exec_incpoke ]
nop
.exec_incpoke
    pop tr1
    lod tr2 tr1
    inc tr2 tr2
    str tr1 tr2
    jmp .next

// Decrement the contents of a given addres
.head_decpoke
dw [ .head_incpoke 0x01 "-!" ]
.code_decpoke
dw [ .exec_decpoke ]
nop
.exec_decpoke
    pop tr1
    lod tr2 tr1
    dec tr2 tr2
    str tr1 tr2
    jmp .next

// Discard the top value on the DS
.head_drop
dw [ .head_decpoke 0x03 "drop" ]
.code_drop
dw [ .exec_drop ]
nop
.exec_drop
    inc dsp dsp
    jmp .next

// Swap the top two values on the DS
.head_swap
dw [ .head_drop 0x03 "swap" ]
.code_swap
dw [ .exec_swap ]
nop
.exec_swap
    pop tr1
    pop tr2
    psh tr1
    psh tr2
    jmp .next

// Duplicate the top value on the DS
.head_dup
dw [ .head_swap 0x02 "dup" ]
.code_dup
dw [ .exec_dup ]
nop
.exec_dup
    lod tr1 dsp
    psh tr1
    jmp .next

// Duplicate the second-to-top value on the DS
.head_over
dw [ .head_dup 0x03 "over" ]
.code_over
dw [ .exec_over ]
nop
.exec_over
    llod tr1 dsp 1
    psh tr1
    jmp .next

// Move the third-to-top value to the top of the DS
.head_rot
dw [ .head_over 0x02 "rot" ]
.code_rot
dw [ .exec_rot ]
nop
.exec_rot
    pop tr1
    pop tr2
    pop tr3
    psh tr2
    psh tr1
    psh tr3
    jmp .next

// Increment the top value on the DS
.head_inc
dw [ .head_rot 0x01 "1+" ]
.code_inc
dw [ .exec_inc ]
nop
.exec_inc
    lod tr1 dsp
    inc tr1 tr1
    str dsp tr1
    jmp .next

// Decrement the top value on the DS
.head_dec
dw [ .head_inc 0x01 "1-" ]
.code_dec
dw [ .exec_dec ]
nop
.exec_dec
    lod tr1 dsp
    dec tr1 tr1
    str dsp tr1
    jmp .next

// Add the top two values on the DS
.head_add
dw [ .head_dec 0x00 "+" ]
.code_add
dw [ .exec_add ]
nop
.exec_add
    pop tr1
    pop tr2
    add tr1 tr2 tr1
    psh tr1
    jmp .next

// Subtract the top two values on the DS
// The top value is subtracted from the second-to-top
.head_sub
dw [ .head_add 0x00 "-" ]
.code_sub
dw [ .exec_sub ]
nop
.exec_sub
    pop tr1
    pop tr2
    sub tr1 tr2 tr1
    psh tr1
    jmp .next

// Multiply the top two values on the DS
.head_mult
dw [ .head_sub 0x00 "*" ]
.code_mult
dw [ .exec_mult ]
nop
.exec_mult
    pop tr1
    pop tr2
    mlt tr1 tr2 tr1
    psh tr1
    jmp .next

// Integer-divide the top two values on the DS
// The second-to-top value is divided by the top value
.head_div
dw [ .head_mult 0x00 "/" ]
.code_div
dw [ .exec_div ]
nop
.exec_div
    pop tr1
    pop tr2
    div tr1 tr2 tr1
    psh tr1
    jmp .next

// Modulo (division remainder) the top two values on the DS
// The second-to-top value is divided by the top value
.head_mod
dw [ .head_div 0x00 "%" ]
.code_mod
dw [ .exec_mod ]
nop
.exec_mod
    pop tr1
    pop tr2
    mod tr1 tr2 tr1
    psh tr1
    jmp .next

// Check if the top two values on the DS are equal
// True is -1 (all 1s), false is 0 (all 0s)
.head_equals
dw [ .head_mod 0x00 "=" ]
.code_equals
dw [ .exec_equals ]
nop
.exec_equals
    pop tr1
    pop tr2
    sete tr1 tr2 tr1
    psh tr1
    jmp .next

// Check if the second-to-top value is
// unsigned-greater-than the top value on the DS
// True is -1 (all 1s), false is 0 (all 0s)
.head_greater
dw [ .head_equals 0x00 ">" ]
.code_greater
dw [ .exec_greater ]
nop
.exec_greater
    pop tr1
    pop tr2
    setg tr1 tr2 tr1
    psh tr1
    jmp .next

// Bitwise AND the top two values on the DS
// Also works as a boolean AND since true is -1
.head_bitand
dw [ .head_greater 0x00 "&" ]
.code_bitand
dw [ .exec_bitand ]
nop
.exec_bitand
    pop tr1
    pop tr2
    and tr1 tr1 tr2
    psh tr1
    jmp .next

// Bitwise OR the top two values on the DS
// Also works as a boolean OR since true is -1
.head_bitor
dw [ .head_bitand 0x00 "|" ]
.code_bitor
dw [ .exec_bitor ]
nop
.exec_bitor
    pop tr1
    pop tr2
    or  tr1 tr1 tr2
    psh tr1
    jmp .next

// Bitwise XOR the top two values on the DS
// Also works as = for two booleans
.head_bitxor
dw [ .head_bitor 0x00 "^" ]
.code_bitxor
dw [ .exec_bitxor ]
nop
.exec_bitxor
    pop tr1
    pop tr2
    xor tr1 tr1 tr2
    psh tr1
    jmp .next

// Bit-negate the top value on the DS
// Also works as a boolean NOT since true is -1
.head_bitnot
dw [ .head_bitxor 0x02 "not" ]
.code_bitnot
dw [ .exec_bitnot ]
nop
.exec_bitnot
    pop tr1
    not tr1 tr1
    psh tr1
    jmp .next

// Skip over the next cell to be executed
// and push its value to the DS
// Used for embedding literal numbers
.head_litn
dw [ .head_bitnot 0x03 "litn" ]
.code_litn
dw [ .exec_litn ]
nop
.exec_litn
    lod tr1 vip
    inc vip vip
    psh tr1
    jmp .next

// Skip over the next few cells to be executed
// Push the first next cell's value to the DS,
// skip that many more cells, and push the address
// of the second next cell to the DS
// Used for embedding literal strings
.head_lits
dw [ .head_litn 0x03 "lits" ]
.code_lits
dw [ .exec_lits ]
nop
.exec_lits
    lod tr1 vip
    inc tr2 vip
    add vip tr2 tr1
    psh tr2
    psh tr1
    jmp .next

// Use the first next cell's value as an offset
// for a jump relative to the offset word
.head_jmp
dw [ .head_lits 0x02 "jmp" ]
.code_jmp
dw [ .exec_jmp ]
nop
.exec_jmp
    lod tr1 vip
    add vip vip tr1
    jmp .next

// Use the first next cell's value as an offset
// for a jump relative to the offset word and only
// do the jump if the top value on the DS was zero
.head_brz
dw [ .head_jmp 0x02 "brz" ]
.code_brz
dw [ .exec_brz ]
nop
.exec_brz
    pop tr1
    brz .exec_jmp tr1
    inc vip vip
    jmp .next

// Pop the top value on the RS and jump to it
// This is effectively a return for procedures
.head_exit
dw [ .head_brz 0x03 "exit" ]
.code_exit
dw [ .exec_exit ]
nop
.exec_exit
    lod vip rsp
    inc rsp rsp
    jmp .next

// Switch to interpret state
.head_interpret
dw [ .head_exit 0x80 "[" ]
.code_interpret
dw [ .exec_interpret ]
nop
.exec_interpret
    llod tr1 .code_state 1
    imm tr1 0
    lstr .code_state 1 tr1
    jmp .next

// Switch to compile state
.head_compile
dw [ .head_interpret 0x00 "]" ]
.code_compile
dw [ .exec_compile ]
nop
.exec_compile
    llod tr1 .code_state 1
    imm tr1 1
    lstr .code_state 1 tr1
    jmp .next

// Given a dictionary entry address,
// toggle the hidden flag of the entry
.head_hide
dw [ .head_compile 0x03 "hide" ]
.code_hide
dw [ .exec_hide ]
nop
.exec_hide
    pop tr1
    llod tr2 tr1 1
    xor tr2 tr2 FLAG_HIDDEN
    lstr tr1 1 tr2
    jmp .next

// Toggle the run-immediate flag of the
// last-defined dictionary entry
.head_runimm
dw [ .head_hide 0x85 "runimm" ]
.code_runimm
dw [ .exec_runimm ]
nop
.exec_runimm
    llod tr1 .code_last 1
    llod tr2 tr1 1
    xor tr2 tr2 FLAG_RUNIMM
    lstr tr1 1 tr2
    jmp .next

// Create and link a new dictionary entry
// given a string on the stack as a name
// String = Length + Address, length on top
.head_create
dw [ .head_runimm 0x05 "create" ]
.code_create
dw [ .exec_create ]
nop
.exec_create
    pop tr1
    pop tr2
    cal .create
    jmp .next

// Pop the top value on the DS and append
// it to the last-defined dictionary entry
.head_append
dw [ .head_create 0x00 "," ]
.code_append
dw [ .exec_append ]
nop
.exec_append
    pop tr1
    cal .append
    jmp .next

// Given a dictionary entry address,
// convert it to an address to its CF
.head_tocfa
dw [ .head_append 0x03 ">cfa" ]
.code_tocfa
dw [ .exec_tocfa ]
nop
.exec_tocfa
    pop tr1
    llod tr2 tr1 1
    and tr2 tr2 MASK_LENGTH
    add tr1 tr1 tr2
    add tr1 tr1 3
    psh tr1
    jmp .next

// Execute a word, given its CFA
.head_exec
dw [ .head_tocfa 0x03 "exec" ]
.code_exec
dw [ .exec_exec ]
nop
.exec_exec
    pop cfa
    lod tr1 cfa
    jmp tr1

// Get a character from the console into the DS
.head_inp
dw [ .head_exec 0x02 "inp" ]
.code_inp
dw [ .exec_inp ]
nop
.exec_inp
    cal .inp
    psh tr2
    jmp .next

// Print out the top value on the DS as a character
.head_out
dw [ .head_inp 0x02 "out" ]
.code_out
dw [ .exec_out ]
nop
.exec_out
    pop tr1
    out %text tr1
    jmp .next

// Print out the top value on the DS as a decimal number
.head_dot
dw [ .head_out 0x00 "." ]
.code_dot
dw [ .exec_dot ]
nop
.exec_dot
    pop tr1
    out %numb tr1
    jmp .next

// Take over reading the next word from the
// console and push its string to the DS
// String = Length + Address, length on top
.head_word
dw [ .head_dot 0x03 "word" ]
.code_word
dw [ .exec_word ]
nop
.exec_word
    cal .word
    psh tr2
    psh tr1
    jmp .next

// Print a string taken from the DS
// String = Length + Address, length on top
.head_tell
dw [ .head_word 0x03 "tell" ]
.code_tell
dw [ .exec_tell ]
nop
.exec_tell
    pop tr1
    pop tr2
    cal .tell
    jmp .next

// Take over reading the next number from the
// console and push its value and the count
// of excess unparsed character to the DS
.head_number
dw [ .head_tell 0x05 "number" ]
.code_number
dw [ .exec_number ]
nop
.exec_number
    pop tr1
    pop tr2
    cal .number
    psh tr2
    psh tr1
    jmp .next

// Find the dictionary entry given a string from the DS
// String = Length + Address, length on top
.head_find
dw [ .head_number 0x03 "find" ]
.code_find
dw [ .exec_find ]
nop
.exec_find
    pop tr1
    pop tr2
    cal .find
    psh tr1
    jmp .next

// Handle compiling or interpreting a given word string
// from the DS or, if not in the dictionary, try to parse
// as a number and push it to the DS, or print error
.head_repl
dw [ .head_find 0x03 "repl" ]
.code_repl
dw [ .exec_repl ]
nop
.exec_repl
    llod tr1 dsp 0
    llod tr2 dsp 1
    cal .find
    brz .exec_repl_nodict tr1
        add dsp dsp 2
        llod tr2 tr1 1
        and tr4 tr2 FLAG_RUNIMM
        and tr2 tr2 MASK_LENGTH
        add tr2 tr2 3
        add cfa tr1 tr2
        bnz .exec_repl_dict_interp tr4
        llod tr4 .code_state 1
        brz .exec_repl_dict_interp tr4
        mov tr1 cfa
        cal .append
        jmp .next
        .exec_repl_dict_interp
        lod tr1 cfa
        jmp tr1
    .exec_repl_nodict
    pop tr1
    pop tr2
    cal .number
    bnz .exec_repl_error tr1
        llod tr4 .code_state 1
        brz .exec_repl_num_interp tr4
        imm tr1 .code_litn
        psh tr2
        cal .append
        pop tr1
        cal .append
        jmp .next
        .exec_repl_num_interp
        psh tr2
        jmp .next
    .exec_repl_error
    out %text '?'
    out %text 'E'
    out %text 'R'
    out %text 'R'
    jmp .next

.head_break
dw [ .head_repl 0x04 "break" ]
.code_break
dw [ .exec_break ]
nop
.exec_break
    @debug
    jmp .next

/////////////////////////// FORTH //////////////////////////

// Our entrypoint word but it can also be called
// from within other words to reset the system

.head_abort
dw [ .head_break 0x04 "abort" ]
.code_abort
dw [ .run_proc ]
dw [ .code_trs .code_rsppoke ] // Clear RS
dw [ .code_word .code_repl ]   // Handle token
dw [ .code_jmp -5 ]            // Repeat

// The word to make all other words, everything between
// it and semicol constitute a new word definiton that
// is compiled and placed on the dictionary

.head_colon
dw [ .head_abort 0x00 ":" ]
.code_colon
dw [ .run_proc ]
dw [ .code_word .code_create ]          // New named entry
dw [ .code_iproc .code_append ]         // Procedure word
dw [ .code_last .code_peek .code_hide ] // Hide it for now
dw [ .code_compile .code_exit ]         // Change state

// Twin of colon, resposible for terminating a definition

.head_semicol
dw [ .head_colon 0x80 ";" ]
.code_semicol
dw [ .run_proc ]
dw [ .code_litn .code_exit .code_append ] // Finalize word
dw [ .code_last .code_peek .code_hide ]   // Unhide it
dw [ .code_interpret .code_exit ]         // Change state

.dict_last
// This word allows for the creation of closures
// It hijacks the caller word to stop execution and then
// patches the newest word on the dictionary to become a
// patch word with itscode as those after itself

.head_patch
dw [ .head_semicol 0x04 "patch" ]
.code_patch
dw [ .run_proc ]
dw [ .code_rtod ] // Start of patch; don't return to it
dw [ .code_last .code_peek .code_tocfa ]  // CFA of last
dw [ .code_ipatch .code_over .code_poke ] // Custom word
dw [ .code_inc .code_poke .code_exit ]    // Store after
