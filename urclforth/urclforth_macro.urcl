run rom
bits 16

// Total RAM = 1024 Cells (2 KiB)
minheap 509
minstack 32

// Forth VM Register Set (8 total)
minreg 7
@define dsp sp // Data Stack Pointer
@define rsp r1 // Return Stack Pointer
@define vip r2 // Virtual Instruction Pointer
@define cfa r3 // Code Field Address
@define tr1 r4 // Temporary Register 1
@define tr2 r5 // Temporary Register 2
@define tr3 r6 // Temporary Register 3
@define tr4 r7 // Temporary Register 4

// The length in the dictionary has a few flags on it too
@define FLAG_RUNIMM 0x80 // Run immediately when encountered
@define FLAG_HIDDEN 0x40 // Ingored by dictionary lookups
@define MASK_LENGTH 0x0f // Only up to 16 chars for the name

@define RS_SIZE  8 // Size of the return stack
@define DS_SIZE 24 // Size of the data stack

////////////////////////////////////////////////////////////
//                    URCL ENTRYPOINT                     //
////////////////////////////////////////////////////////////

// The last 8 cells are for the RSP
// Memset them to AAAA so they are visible
mov rsp sp
imm tr1 RS_SIZE
.fill_rs
    psh 0xAAAA
    dec tr1 tr1
bnz .fill_rs tr1

// The following 24 cells are for the DSP
// Memset them to BBBB so they are visible
sub tr1 r0 DS_SIZE
.fill_ds
    lstr dsp tr1 0xBBBB
    inc tr1 tr1
bnz .fill_ds tr1

// Initialise TDS, TRS, EDR constants
lstr .code_tds 1 dsp
lstr .code_trs 1 rsp
sub tr1 dsp DS_SIZE
lstr .code_edr 1 tr1

// Inline version of .next to call the abort word
// Don't want to place down a DW just for this
imm cfa .code_abort
lod tr1 cfa
jmp tr1

////////////////////////////////////////////////////////////
//                   RUNTIME ESSENTIALS                   //
////////////////////////////////////////////////////////////

// Every primitive word ends by jumping here
// Jump to the next word's CFA and advance the VIP
.next
    lod cfa vip
    inc vip vip
    lod tr1 cfa
    jmp tr1

// CFA of procedure words points to this
// Saves the VIP to the RS and jumps to the
// word sequence in the DF of the word
.run_proc
    dec rsp rsp
    str rsp vip
    add vip cfa 1
    jmp .next

// CFA of patch words points to this
// Saves the VIP to the RS, jumps to the
// word sequence pointed to by the cell
// after the CF and pushes the address
// of the address after that to the DS
.run_patch
    dec rsp rsp
    str rsp vip
    llod vip cfa 1
    add tr1 cfa 2
    psh tr1
    jmp .next

// CFA of constant words points to this
// Pushes to the DS the first cell of
// the DF of the word
.run_const
    llod tr1 cfa 1
    psh tr1
    jmp .next

// CFA of variable words points to this
// Pushes to the DS the address of
// the DF of the word
.run_var
    add tr1 cfa 1
    psh tr1
    jmp .next

////////////////////////////////////////////////////////////
//                    HELPER FUNCTIONS                    //
////////////////////////////////////////////////////////////

.inp
    llod tr2 .src_preload_state 0
    sbrl .inp_storage tr2 1
    .inp_hasinit
    in  tr2 %text
    out %text tr2
    ret
    .inp_storage
    not tr2 tr2
    lstr .src_preload_state 0 tr2
    llod tr3 .src_preload_state 1
    out %addr tr3
    bnz .inp_noinc tr2
        inc tr3 tr3
        in  tr4 %addr
        bne ~+2 tr3 tr4
        lstr .src_preload_state 0 1
        lstr .src_preload_state 1 tr3
    .inp_noinc
    mov tr4 tr2
    in  tr2 %bus
    brz ~+2 tr4
    bsr tr2 tr2 8
    and tr2 tr2 0xFF
    ret

.tell
    brz .tell_done tr1
        lod tr3 tr2
        out %text tr3
        inc tr2 tr2
        dec tr1 tr1
    jmp .tell
    .tell_done
    ret

.word
    imm tr1 0
    .word_loop1
        cal .inp
    ble .word_loop1 tr2 ' '
    .word_loop2
        lstr .word_buffer tr1 tr2
        inc tr1 tr1
        bre .word_skip tr1 16
        cal .inp
    brg .word_loop2 tr2 ' '
    .word_skip
    imm tr2 .word_buffer
    ret

.number
    imm tr3 0
    .number_next
    brz .number_done tr1
        lod tr4 tr2
        sub tr4 tr4 '0'
        bge .number_done tr4 10
        mlt tr3 tr3 10
        add tr3 tr3 tr4
        inc tr2 tr2
        dec tr1 tr1
    jmp .number_next
    .number_done
    mov tr2 tr3
    ret

.find
    dec tr1 tr1
    add cfa .code_last 1
    .find_next
        lod cfa cfa
        llod tr3 cfa 1
        and tr4 tr3 FLAG_HIDDEN
        bnz .find_length_skip tr4
        and tr3 tr3 MASK_LENGTH
        bne .find_length_skip tr3 tr1
            psh tr1
            add cfa cfa 2
            .find_compare
                llod tr3 cfa tr1
                llod tr4 tr2 tr1
                bne .find_compare_skip tr3 tr4
                dec tr1 tr1
            brp .find_compare tr1
            pop tr1
            sub tr1 cfa 2
            ret
            .find_compare_skip
            pop tr1
            sub cfa cfa 2
        .find_length_skip
    bnz .find_next cfa
    mov tr1 cfa
    ret

.create
    llod tr3 .code_here 1
    llod tr4 .code_last 1
    lstr .code_last 1 tr3
    lstr tr3 0 tr4
    and tr1 tr1 MASK_LENGTH
    dec tr4 tr1
    lstr tr3 1 tr4
    add tr3 tr3 2
    add tr4 tr3 tr1
    lstr .code_here 1 tr4
    .create_copy
        dec tr1 tr1
        llod tr4 tr2 tr1
        lstr tr3 tr1 tr4
    bnz .create_copy tr1
    .create_exit
    ret

.append
    llod tr2 .code_here 1
    str tr2 tr1
    inc tr2 tr2
    lstr .code_here 1 tr2
    ret

////////////////////////////////////////////////////////////
//                INITIAL WORD DICTIONARY                 //
////////////////////////////////////////////////////////////

.src_preload_state // 0=upper,-1=lower,1=done %addr
dw [ 0 0 ]

.word_buffer // Maximum 16 chars between whitespaces
dw [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ]

/////////////////// CONSTANTS + VARIABLES //////////////////

// 0=Interpret, 1=Compile
@defvar "state" state 0
// First free cell on the dictionary region
@defvar "here"  here  M0
// Last-defined dictionary entry
@defvar "last"  last  .dict_last

// Top of Data Stack
@defconst "tds" tds 0
// Top of Return Stack
@defconst "trs" trs 0
// End of Dictionary Region
@defconst "edr" edr 0

// CFA for procedures
@defconst "iproc"  iproc  .run_proc
// CFA for patch words
@defconst "ipatch" ipatch .run_patch
// CFA for variables
@defconst "ivar"   ivar   .run_var
// CFA for constants
@defconst "iconst" iconst .run_const

// Bit for the run-immediate flag
@defconst "frunimm" frunimm FLAG_RUNIMM
// Bit for the hidden flag
@defconst "fhidden" fhidden FLAG_HIDDEN
// Length bitmask for dictionary entries
@defconst "nlength" nlength MASK_LENGTH

//////////////////////// PRIMITIVES ////////////////////////

// Get the value of the Return Stack Pointer on the DS
@defprim "rsp@" rsppeek
    psh rsp
    jmp .next

// Store the value on the DS to the Return Stack Pointer
@defprim "rsp!" rsppoke
    pop rsp
    jmp .next

// Get the value of the Data Stack Pointer on the DS
@defprim "dsp@" dsppeek
    psh dsp
    jmp .next

// Store the value on the DS to the Data Stack Pointer
@defprim "dsp!" dsppoke
    pop dsp
    jmp .next

// Transfer a value from the DS to the RS
@defprim "d>r" dtor
    pop tr1
    dec rsp rsp
    str rsp tr1
    jmp .next

// Transfer a value fromn the RS to the DS
@defprim "r>d" rtod
    lod tr1 rsp
    inc rsp rsp
    psh tr1
    jmp .next

// Read a value at a given address
@defprim "@" peek
    pop tr1
    lod tr1 tr1
    psh tr1
    jmp .next

// Store a given value to a given addres
// Address is ontop of the value
@defprim "!" poke
    pop tr1
    pop tr2
    str tr1 tr2
    jmp .next

// Increment the contents of a given addres
@defprim "+!" incpoke
    pop tr1
    lod tr2 tr1
    inc tr2 tr2
    str tr1 tr2
    jmp .next

// Decrement the contents of a given addres
@defprim "-!" decpoke
    pop tr1
    lod tr2 tr1
    dec tr2 tr2
    str tr1 tr2
    jmp .next

// Discard the top value on the DS
@defprim "drop" drop
    inc dsp dsp
    jmp .next

// Swap the top two values on the DS
@defprim "swap" swap
    pop tr1
    pop tr2
    psh tr1
    psh tr2
    jmp .next

// Duplicate the top value on the DS
@defprim "dup" dup
    lod tr1 dsp
    psh tr1
    jmp .next

// Duplicate the second-to-top value on the DS
@defprim "over" over
    llod tr1 dsp 1
    psh tr1
    jmp .next

// Move the third-to-top value to the top of the DS
@defprim "rot" rot
    pop tr1
    pop tr2
    pop tr3
    psh tr2
    psh tr1
    psh tr3
    jmp .next

// Increment the top value on the DS
@defprim "1+" inc
    lod tr1 dsp
    inc tr1 tr1
    str dsp tr1
    jmp .next

// Decrement the top value on the DS
@defprim "1-" dec
    lod tr1 dsp
    dec tr1 tr1
    str dsp tr1
    jmp .next

// Add the top two values on the DS
@defprim "+" add
    pop tr1
    pop tr2
    add tr1 tr2 tr1
    psh tr1
    jmp .next

// Subtract the top two values on the DS
// The top value is subtracted from the second-to-top
@defprim "-" sub
    pop tr1
    pop tr2
    sub tr1 tr2 tr1
    psh tr1
    jmp .next

// Multiply the top two values on the DS
@defprim "*" mult
    pop tr1
    pop tr2
    mlt tr1 tr2 tr1
    psh tr1
    jmp .next

// Integer-divide the top two values on the DS
// The second-to-top value is divided by the top value
@defprim "/" div
    pop tr1
    pop tr2
    div tr1 tr2 tr1
    psh tr1
    jmp .next

// Modulo (division remainder) the top two values on the DS
// The second-to-top value is divided by the top value
@defprim "%" mod
    pop tr1
    pop tr2
    mod tr1 tr2 tr1
    psh tr1
    jmp .next

// Check if the top two values on the DS are equal
// True is -1 (all 1s), false is 0 (all 0s)
@defprim "=" equals
    pop tr1
    pop tr2
    sete tr1 tr2 tr1
    psh tr1
    jmp .next

// Check if the second-to-top value is
// unsigned-greater-than the top value on the DS
// True is -1 (all 1s), false is 0 (all 0s)
@defprim ">" greater
    pop tr1
    pop tr2
    setg tr1 tr2 tr1
    psh tr1
    jmp .next

// Bitwise AND the top two values on the DS
// Also works as a boolean AND since true is -1
@defprim "&" bitand
    pop tr1
    pop tr2
    and tr1 tr1 tr2
    psh tr1
    jmp .next

// Bitwise OR the top two values on the DS
// Also works as a boolean OR since true is -1
@defprim "|" bitor
    pop tr1
    pop tr2
    or  tr1 tr1 tr2
    psh tr1
    jmp .next

// Bitwise XOR the top two values on the DS
// Also works as = for two booleans
@defprim "^" bitxor
    pop tr1
    pop tr2
    xor tr1 tr1 tr2
    psh tr1
    jmp .next

// Bit-negate the top value on the DS
// Also works as a boolean NOT since true is -1
@defprim "not" bitnot
    pop tr1
    not tr1 tr1
    psh tr1
    jmp .next

// Skip over the next cell to be executed
// and push its value to the DS
// Used for embedding literal numbers
@defprim "litn" litn
    lod tr1 vip
    inc vip vip
    psh tr1
    jmp .next

// Skip over the next few cells to be executed
// Push the first next cell's value to the DS,
// skip that many more cells, and push the address
// of the second next cell to the DS
// Used for embedding literal strings
@defprim "lits" lits
    lod tr1 vip
    inc tr2 vip
    add vip tr2 tr1
    psh tr2
    psh tr1
    jmp .next

// Use the first next cell's value as an offset
// for a jump relative to the offset word
@defprim "jmp" jmp
    lod tr1 vip
    add vip vip tr1
    jmp .next

// Use the first next cell's value as an offset
// for a jump relative to the offset word and only
// do the jump if the top value on the DS was zero
@defprim "brz" brz
    pop tr1
    brz .exec_jmp tr1
    inc vip vip
    jmp .next

// Pop the top value on the RS and jump to it
// This is effectively a return for procedures
@defprim "exit" exit
    lod vip rsp
    inc rsp rsp
    jmp .next

// Switch to interpret state
@defprimi "[" interpret
    llod tr1 .code_state 1
    imm tr1 0
    lstr .code_state 1 tr1
    jmp .next

// Switch to compile state
@defprim "]" compile
    llod tr1 .code_state 1
    imm tr1 1
    lstr .code_state 1 tr1
    jmp .next

// Given a dictionary entry address,
// toggle the hidden flag of the entry
@defprim "hide" hide
    pop tr1
    llod tr2 tr1 1
    xor tr2 tr2 FLAG_HIDDEN
    lstr tr1 1 tr2
    jmp .next

// Toggle the run-immediate flag of the
// last-defined dictionary entry
@defprimi "runimm" runimm
    llod tr1 .code_last 1
    llod tr2 tr1 1
    xor tr2 tr2 FLAG_RUNIMM
    lstr tr1 1 tr2
    jmp .next

// Create and link a new dictionary entry
// given a string on the stack as a name
// String = Length + Address, length on top
@defprim "create" create
    pop tr1
    pop tr2
    cal .create
    jmp .next

// Pop the top value on the DS and append
// it to the last-defined dictionary entry
@defprim "," append
    pop tr1
    cal .append
    jmp .next

// Given a dictionary entry address,
// convert it to an address to its CF
@defprim ">cfa" tocfa
    pop tr1
    llod tr2 tr1 1
    and tr2 tr2 MASK_LENGTH
    add tr1 tr1 tr2
    add tr1 tr1 3
    psh tr1
    jmp .next

// Execute a word, given its CFA
@defprim "exec" exec
    pop cfa
    lod tr1 cfa
    jmp tr1

// Get a character from the console into the DS
@defprim "inp" inp
    cal .inp
    psh tr2
    jmp .next

// Print out the top value on the DS as a character
@defprim "out" out
    pop tr1
    out %text tr1
    jmp .next

// Print out the top value on the DS as a decimal number
@defprim "." dot
    pop tr1
    out %numb tr1
    jmp .next

// Take over reading the next word from the
// console and push its string to the DS
// String = Length + Address, length on top
@defprim "word" word
    cal .word
    psh tr2
    psh tr1
    jmp .next

// Print a string taken from the DS
// String = Length + Address, length on top
@defprim "tell" tell
    pop tr1
    pop tr2
    cal .tell
    jmp .next

// Take over reading the next number from the
// console and push its value and the count
// of excess unparsed character to the DS
@defprim "number" number
    pop tr1
    pop tr2
    cal .number
    psh tr2
    psh tr1
    jmp .next

// Find the dictionary entry given a string from the DS
// String = Length + Address, length on top
@defprim "find" find
    pop tr1
    pop tr2
    cal .find
    psh tr1
    jmp .next

// Handle compiling or interpreting a given word string
// from the DS or, if not in the dictionary, try to parse
// as a number and push it to the DS, or print error
@defprim "repl" repl
    llod tr1 dsp 0
    llod tr2 dsp 1
    cal .find
    brz .exec_repl_nodict tr1
        add dsp dsp 2
        llod tr2 tr1 1
        and tr4 tr2 FLAG_RUNIMM
        and tr2 tr2 MASK_LENGTH
        add tr2 tr2 3
        add cfa tr1 tr2
        bnz .exec_repl_dict_interp tr4
        llod tr4 .code_state 1
        brz .exec_repl_dict_interp tr4
        mov tr1 cfa
        cal .append
        jmp .next
        .exec_repl_dict_interp
        lod tr1 cfa
        jmp tr1
    .exec_repl_nodict
    pop tr1
    pop tr2
    cal .number
    bnz .exec_repl_error tr1
        llod tr4 .code_state 1
        brz .exec_repl_num_interp tr4
        imm tr1 .code_litn
        psh tr2
        cal .append
        pop tr1
        cal .append
        jmp .next
        .exec_repl_num_interp
        psh tr2
        jmp .next
    .exec_repl_error
    out %text '?'
    out %text 'E'
    out %text 'R'
    out %text 'R'
    jmp .next

@defprim "break" break
    @debug
    jmp .next

/////////////////////////// FORTH //////////////////////////

// Our entrypoint word but it can also be called
// from within other words to reset the system
@defforth "abort" abort
dw [ .code_trs .code_rsppoke ] // Clear RS
dw [ .code_word .code_repl ]   // Handle token
dw [ .code_jmp -5 ]            // Repeat

// The word to make all other words, everything between
// it and semicol constitute a new word definiton that
// is compiled and placed on the dictionary
@defforth ":" colon
dw [ .code_word .code_create ]          // New named entry
dw [ .code_iproc .code_append ]         // Procedure word
dw [ .code_last .code_peek .code_hide ] // Hide it for now
dw [ .code_compile .code_exit ]         // Change state

// Twin of colon, resposible for terminating a definition
@defforthi ";" semicol
dw [ .code_litn .code_exit .code_append ] // Finalize word
dw [ .code_last .code_peek .code_hide ]   // Unhide it
dw [ .code_interpret .code_exit ]         // Change state

.dict_last
// This word allows for the creation of closures
// It hijacks the caller word to stop execution and then
// patches the newest word on the dictionary to become a
// patch word with itscode as those after itself
@defforth "patch" patch
dw [ .code_rtod ] // Start of patch; don't return to it
dw [ .code_last .code_peek .code_tocfa ]  // CFA of last
dw [ .code_ipatch .code_over .code_poke ] // Custom word
dw [ .code_inc .code_poke .code_exit ]    // Store after
